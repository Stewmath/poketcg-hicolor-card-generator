// TODO: Permissive License

#include <gbdk/platform.h>
#include <gbdk/incbin.h>
#include <gb/isr.h>

#include <gbc_hicolor.h>

#define MIN(A,B) ((A)<(B)?(A):(B))

static uint16_t SP_SAVE;
static uint8_t * p_hicolor_palettes;


// ISR function which updates 4 CGB palettes per scanline
// alternating between Palettes 0-3 and 4-7
void hicolor_palette_isr(void) NONBANKED {
__asm
        ld (_SP_SAVE), sp           ; save SP

        ld a, (_p_hicolor_palettes + 1)  ; load address of picture palettes buffer
        ld d, a
        ld a, (_p_hicolor_palettes + 0)
        ld e, a

        ldh a, (_SCY_REG)
        swap a
        ld l, a
        and #0x0f
        ld h, a
        ld a, #0xf0
        and l
        ld l, a
        add hl, hl
        add hl, de                  ; offset address by SCY * (4 * 4 * 2)
        ld sp, hl

        rlca                        ; compensate odd/even line
        and #0x20                   ; if odd then start from 4-th palette; offset == 32
        or  #0x80                   ; set auto-increment

        ld hl,#_BCPS_REG
        ld (hl+), a                 ; HL now points to BCPD

        .rept (8*4)                 ; read and set the the colors that come from previous lines
            pop de
            ld (hl), e
            ld (hl), d
        .endm

0$:
        ldh a, (_STAT_REG)
        and #STATF_BUSY
        jr z, 0$                    ; wait for mode 3

        ld a, #STATF_MODE00
        ld (_STAT_REG), a
        xor a
        ld (_IF_REG), a

1$:
        pop de                      ; preload the first two colors
        pop bc

        xor a
        ld (_IF_REG), a
        halt                        ; wait for mode 0

        ld (hl), e                  ; set the first two colors
        ld (hl), d
        ld (hl), c
        ld (hl), b

        .rept (4*4)-2
            pop de                  ; read and set the rest of the colors
            ld (hl), e
            ld (hl), d
        .endm

        ldh a, (_LY_REG)
        cp #143
        jr c, 1$                    ; load the next 4 palettes

        ld a, #STATF_LYC
        ld (_STAT_REG), a
        xor a
        ld (_IF_REG), a

        ld hl, #_SP_SAVE            ; restore SP
        ld a, (hl+)
        ld h, (hl)
        ld l, a
        ld sp, hl

        ret
__endasm;
}


// Loads Tile Patterns, Map and Map Attributes for the HiColor image,
// then installs the HiColor ISR handler which updates palettes per scanline.
//
// The intput argument should be a pointer to the struct generated by the
// png2hicolorgb program with C source output mode enabled
void hicolor_start(hicolor_data * p_hicolor) NONBANKED {
    // Copy address of palette into local var used by HiColor ISR
    p_hicolor_palettes = p_hicolor->p_palette;

    // Load the first 256 tiles or less and set BG Map
    VBK_REG = VBK_TILES;

    // TODO: change vmemcpy() to set_bkg_tiles(), after changing converter to emit data in proper order, use vmemcpy() for now

    vmemcpy(_VRAM8800, p_hicolor->p_tiles, MIN(p_hicolor->tile_count, 256) * 16);    
    set_bkg_tiles(0u, 0u, DEVICE_SCREEN_WIDTH, p_hicolor->height_in_tiles, p_hicolor->p_map);

    // Load remaining 256 tiles and set Attribute Map into alternate bank
    VBK_REG = VBK_ATTRIBUTES;
    if (p_hicolor->tile_count > 256) vmemcpy(_VRAM8800, p_hicolor->p_tiles + (256 * 16), (p_hicolor->tile_count - 256) * 16);    
    set_bkg_tiles(0, 0, DEVICE_SCREEN_WIDTH, p_hicolor->height_in_tiles, p_hicolor->p_attribute_map);
    VBK_REG = VBK_TILES;

    // Set up and install the HiColor ISR
    CRITICAL {
        LYC_REG = 152;
        STAT_REG = STATF_LYC;
        // prevent installing HiColor ISR twice
        remove_LCD(hicolor_palette_isr);
        // install the HiColor ISR
        add_LCD(hicolor_palette_isr);
    }
    set_interrupts(IE_REG | LCD_IFLAG);
}

// De-installs the HiColor ISR handler
void hicolor_stop(void) NONBANKED {
    // Turn off and de-install the HiColor ISR
    set_interrupts(IE_REG & ~LCD_IFLAG);
    CRITICAL {
        remove_LCD(hicolor_palette_isr);
    }
}

